#!/bin/bash

scriptdir="$(dirname $(which $0))"
cluster_user="${USER%%@*}"

. ${scriptdir}/server.conf

: ${run_shorah:=0}
: ${staging:=1}

if [[ $(realpath $scriptdir) != $(realpath $basedir) ]]; then
	echo "$scriptdir vs $basedir"
fi

if [[ ! $mode =~ ^[0-7]{,4}$ ]]; then
	echo "Invalid characters <${mode//[0-7]/}> in <${mode}>"
	echo 'mode should be an octal chmod value, see `mkdir --help` for informations'
	mode=
fi

cd ${basedir}

umask 0002

statusdir="${basedir}/status"
mkdir ${mode:+--mode=${mode}} -p ${statusdir}
viloca_statusdir="${basedir}/${viloca_basedir}/status"
mkdir ${mode:+--mode=${mode}} -p ${viloca_statusdir}
viloca_staging=${viloca_samples}.staging
lockfile=${statusdir}/carillon_lock

remote_batman="ssh -ni ${HOME}/.ssh/id_ed25519_batman -l ${cluster_user} euler.ethz.ch --"
remote_belfry="ssh -ni ${HOME}/.ssh/id_ed25519_belfry bs-bewi09.ethz.ch --"

touch ${statusdir}/oh_hai_im_lopping

if false; then # disable block
#
# Avoid re-entry
#

if lockfile -2 -r 1 "${lockfile}"; then
	# save the PID in the lockfile
	chmod u+w "${lockfile}"
	echo "$$" > "${lockfile}"
	chmod 0444 "${lockfile}"
else
	PID=$(<"${lockfile}")

	echo -e "Previous run still running (PID=${pid})\n"

	if [ -d "/proc/${pid}" ]; then
		ps --forest -o 'pid,ppid,sess,user,stime,time,%cpu,ni,args' --pid "${pid}" --ppid "${pid}" -g "$(ps -o 'sid=' --pid "${pid}" --ppid "${pid}"|uniq)"
	else
		echo "*CANNOT FIND PID ${pid}*"
		echo "perhaps process has crashed"
		echo "to force restart, manually delete lock file :"
		echo -e "\trm ${lockfile}"
		exit 2;
	fi
	exit 1;
fi
fi # disable block



#
# Phase 1: periodic data sync
#

echo '========='
echo 'Data sync'
echo '========='

[[ -n $skipsync ]] && echo "Hack: ${skipsync} will be skiped."
#[[ $skipsync != h2030   ]] && ${scriptdir}/belfry synch2030 # --recent : there are no old archive at Health2030 anyway
#[[ $skipsync != violler ]] && ${scriptdir}/belfry syncviollier # --recent : there are no old archive, we're even supposed to perform the deletion
[[ $skipsync != fgcz    ]] && ${scriptdir}/belfry syncfgcz --recent
#[[ $skipsync != gfb     ]] && ${scriptdir}/belfry syncopenbis --recent
${scriptdir}/belfry sortsamples --recent $([[ ${statusdir}/syncopenbis_last -nt ${statusdir}/syncopenbis_new ]] && echo '--summary')

# uploading requests require prior successful download
if [[ ( -e ${statusdir}/sortsamples_fail ) && ( ${statusdir}/sortsamples_fail -nt  ${statusdir}/sortsamples_success ) ]]; then
	echo 'warning: cannot serve upload requests sampleset data not successfully fetched yet' > /dev/stderr
else
	${scriptdir}/belfry uploadrequests
fi

echo '---------'
if [[ !  ${statusdir}/syncopenbis_last -nt ${statusdir}/syncopenbis_new ]]; then
	echo "Data was copied: $(<${statusdir}/syncopenbis_new)"
	limit=$(date --date='1 week ago' '+%Y%m%d')
	echo "Fixing perms back until $limit:"
	for d in $(echo ${basedir}/${download}/20* | grep -oP "(?<=/${download}/)(20[0-9][0-9][0-1][0-9][0-3][0-9])" | sort -r -u); do
		if [[ "$d" < "$limit" ]]; then
			echo '...done'
			break
		else
			echo "...${d}..."
		fi
		${scriptdir}/belfry fixopenbisrights "${d}"
	done
fi



#
# Phase 2: update status of current run and trigger backups
#

echo "================="
echo "Check current run"
echo "================="

if [[ ( -e ${statusdir}/vpipe_started ) && ( ( ! -e ${statusdir}/vpipe_ended ) || ( ${statusdir}/vpipe_started -nt ${statusdir}/vpipe_ended ) ) ]]; then
	stillrunning=0
	while read j id; do
		# skip missing
		if [[ -z "${id}" ]]; then
			echo "$j : (not started)"
			continue
		fi

		# skip already finished
		if [[ ( -e ${statusdir}/vpipe_${j}_ended ) && ( ${statusdir}/vpipe_${j}_ended -nt ${statusdir}/vpipe_started ) ]]; then
			old="$(<${statusdir}/vpipe_${j}_ended)"
			if [[ "${id}" == "${old}" ]]; then
				echo "$j : $id already finished"
			else
				echo "$j : mismatch $id vs $old"
			fi
			continue
		fi

		# cluster status
		stat=$(${remote_batman} job "${id}" || echo "(no answer)")
		if [[ ( -n "${stat}" ) && ( ! "${stat}" =~ (EXIT|DONE) ) ]]; then
			# running
			echo -n "$j : $id : $stat"
			(( ++stillrunning ))
			if [[ "${stat}" == 'RUN' && ( ! "$j" =~ qa$ ) ]]; then
				echo -ne '\t'
				${remote_batman} completion "${id}" | tail -n 1
			else
				echo ''
			fi
			sleep 1
			continue
		fi

		# not running
		echo "$j : $id finishing"

		case "$j" in
			seqqa)
				${scriptdir}/belfry pullsamples_noshorah --recent
				if [[ ( -e ${statusdir}/pullsamples_noshorah_fail ) && ( ${statusdir}/pullsamples_noshorah_fail -nt ${statusdir}/pullsamples_noshorah_success ) ]]; then
					echo "pulling data failed"
					(( ++stillrunning ))
					continue
				fi
			;;
		esac

		echo "${id}" > ${statusdir}/vpipe_${j}_ended
	done < ${statusdir}/vpipe_started

	if (( stillrunning == 0 )); then
		# HACK temporarily avoid copying over ShoRAH files
		#${scriptdir}/belfry pullsamples --recent
		#if [[ ( ! -e ${statusdir}/pullsamples_fail ) || ( ${statusdir}/pullsamples_success -nt ${statusdir}/pullsamples_fail ) ]]; then
		${scriptdir}/belfry pullsamples_noshorah --recent
		if [[ ( ! -e ${statusdir}/pullsamples_noshorah_fail ) || ( ${statusdir}/pullsamples_noshorah_success -nt ${statusdir}/pullsamples_noshorah_fail ) ]]; then
			echo "$(basename $(realpath ${statusdir}/vpipe_started))" > ${statusdir}/vpipe_ended
		else
			echo "pulling data failed"
		fi
	fi
else
	echo 'No current run.'
fi



#
# Phase 3: Reports and sequences
#

echo "================"
echo "Results handling"
echo "================"

if [[ ( -e ${statusdir}/pullsamples_noshorah_success || -e ${statusdir}/pullsamples_success ) && ( ( ! -e ${statusdir}/qa_report_success ) || ( ${statusdir}/pullsamples_noshorah_success -nt ${statusdir}/qa_report_success ) || (  ${statusdir}/pullsamples_success -nt ${statusdir}/qa_report_success ) ) ]]; then
	#${scriptdir}/belfry qa_report
	touch ${statusdir}/qa_report_success
else
	echo 'no newer results'
fi

if [[ ( -e ${statusdir}/qa_report_success ) && ( ( ! -e ${statusdir}/pushseq_success ) || ( ${statusdir}/qa_report_success -nt ${statusdir}/pushseq_success ) ) ]]; then
	:
	${scriptdir}/belfry pushseq
	#${scriptdir}/belfry gitaddseq
else
	echo 'no upload needed'
fi



#
# Phase 4: restart runs if new data
#

echo "============="
echo "Start new run"
echo "============="

# TODO support a yaml with regex
rxsample='(^[[:digit:]]{6,}_)|(^[[:digit:]]{8,})|(^Y[[:digit:]]{8,})|([[:digit:]]{2}_20[[:digit:]]{2}_[01]?[[:digit:]]_[0-3]?[[:digit:]])|(^KLZHC[oO][vV])|(^B[aA][[:digit:]]{4,})|(^USB_20[[:digit:]]{2}_[01]?[[:digit:]]_[[:digit:]]{2}_.{8})'

scanmissingsamples() {
	while read sample batch other; do 
		# look for only guaranteed samples
		[[ $sample =~ $rxsample ]] || continue
		# check the presence of fasta on each sample
		if [[ -e ${basedir}/${working}/samples/${sample}/${batch}/upload_prepared.touch ]]; then
			# this will check for:
			#  - references/ref_majority.fasta
			#  - references/consensus.bcftools.fasta & .chain
			#  - references/frameshift_deletions_check.tsv
			#  etc.
			#  see V-pipe's rule 'prepare_upload' in publish.smk
			echo -n '.'
		else 
			echo -e "\r+${batch/_/:}\t!${sample}\e[K"
			true
			return 0
		fi; 
	done < $1
	false
}

# like "$*" but with a different field separator than default.
join_by() { local IFS="$1"; shift; echo "$*"; }

if [[ ( ( ! -e ${statusdir}/vpipe_ended ) && ( ! -e ${statusdir}/vpipe_started ) ) || ( ${statusdir}/vpipe_ended -nt ${statusdir}/vpipe_started ) ]]; then
	clearline=0
	mustrun=0
	runreason=( )
	declare -A flowcell
	ref=$(date --reference="${statusdir}/vpipe_started" '+%Y%m%d')
	now=$(date '+%Y%m%d')
	limit=$(date --date='2 weeks ago' '+%Y%m%d')
	echo "Check batch against ${ref}:"
	for t in ${basedir}/${sampleset}/samples.*.tsv; do
		if [[ ! $t =~ samples.([[:digit:]]{8})_([[:alnum:]]{5,}(-[[:digit:]]+)?).tsv$ ]]; then
			echo "oops: Can't parse <${t}> ?!" > /dev/stderr
		fi

		# check Duplicates
		b="${BASH_REMATCH[1]}"
		f="${BASH_REMATCH[2]}"
		if [[ -n "${flowcell[$f]}" ]]; then
			echo "error: Duplicate flowcell $f : ${flowcell[$f]} vs $b" > /dev/stderr
			exit 2
		else
			flowcell[$f]=$b
		fi

		# check dates
		if (( clearline )) && [[ "$limit" < "$b"  ]]; then
			echo -ne "\n"
			clearline=0
		fi
		if [[ "$ref" < "$b" || "$ref" == "$b" ]]; then
			echo "!$b:$f"
			(( ++mustrun ))
			runreason+=( "${b}_${f}" )
		elif [[ "$limit" < "$b"  ]] && scanmissingsamples $t; then 
			(( ++mustrun ))
			runreason+=( "${b}_${f}" )
		else
			if  [[ "$limit" < "$b"  ]]; then
				echo -e "\r($b:$f)\e[K"
			else
				echo -ne "($b:$f)\t"
				clearline=1
			fi
		fi
		# sanity check
		if [[ "$now" < "$b" ]]; then
			echo "oops: in the future $b vs $now"
		fi
	done

	# are we allowed to submit jobs ?
	if (( donotsubmit )); then
		echo -e '\e[35;1mWill NOT submit jobs\e[0m...' > /dev/stderr
		if (( mustrun )); then
			echo 'submit blocked' > ${statusdir}/submit_fail
			echo -e '...\e[33;1mbut there are new jobs that should be started !!!\e[0m' > /dev/stderr
		else
			echo '...and there is nothing to run anyway' > /dev/stderr
		fi
	# start jobs ?
	elif (( mustrun )); then
		echo 'Will start new job'

		# Sanity check
		if [[ ( -e ${statusdir}/sortsamples_fail ) && ( ${statusdir}/sortsamples_fail -nt  ${statusdir}/sortsamples_success ) ]]; then
			if (( staging )); then
				echo -e '\e[33;1mwarning: sampleset data not successfully fetched yet, using staging\e[0m' > /dev/stderr
			else
				echo 'data fetch error' > ${statusdir}/submit_fail
				echo -e '\e[31;1merror: sampleset data not successfully fetched yet\e[0m' > /dev/stderr
				exit 1
			fi
		fi
		if [[ ( ! -e ${statusdir}/syncopenbis_new ) || ( ( -e ${statusdir}/vpipe_started ) && ( ${statusdir}/vpipe_started -nt ${statusdir}/syncopenbis_new ) ) ]]; then
			echo 'oops: something fishy: no downloaded data newer than last run ?' > /dev/stderr
		fi
		# point of comparison for dates:
		if [[ -e ${statusdir}/vpipe_ended ]]; then
			lastrun=${statusdir}/vpipe_ended
		else
			# find the most recent 'new' sync status
			lastsync=( $(ls -t ${statusdir}/sync*_new) )
			if [[ -e "${lastsync[0]}" ]]; then
				lastrun="${lastsync[0]}"
			else
				# last fall back: sort success
				lastrun=${statusdir}/sortsamples_success
			fi
		fi

		# push sampleset data
		if [[ ( ! -e ${statusdir}/pushsampleset_success ) || ( ${lastrun} -nt ${statusdir}/pushsampleset_success ) ]]; then
			${scriptdir}/belfry pushsampleset --recent
		else
			echo 'oops: Sampleset already pushed' > /dev/stderr
		fi

		# must run
		if [[ ( -e ${statusdir}/pushsampleset_fail ) && ( ${statusdir}/pushsampleset_fail -nt ${statusdir}/pushsampleset_success ) ]]; then
			echo 'error: Pushing sampleset did not succeed' > /dev/stderr
		else
			echo 'starting jobs'
			if (( run_shorah )); then
				shorah=""
			else
				shorah="--no-shorah"
			fi
			${remote_batman} addsamples --recent	&& \
			${remote_batman} vpipe ${shorah} --recent --tag "$(join_by ';' "${runreason[@]}")" > ${statusdir}/vpipe.${now}	&&	\
			if [[ -s ${statusdir}/vpipe.${now} ]]; then
				ln -sf vpipe.${now} ${statusdir}/vpipe_started
				cat ${statusdir}/vpipe_started
				printf "%s\t$(date '+%H%M%S')\n" "${runreason[@]}" | tee -a ${statusdir}/vpipe_new.${now}
				if [[ -n "${mailto[*]}" ]]; then
					(
						echo '(Possibly new) samples not having consensus sequences yet found in batches:'
						printf ' - %s\n' "${runreason[@]}"
						echo -e '\nStarting V-pipe on Euler:'
						cat ${statusdir}/vpipe_started
					) | mail -s '[Automation-carillon] Starting V-pipe on Euler' "${mailto[@]}"
					# -r "${mailfrom}"
				fi
			fi
		fi
	else
		echo 'No new jobs to start'

		# check for left-over .staging files
		staging_tsv=( sampleset/samples.202*.tsv.staging )
		if [[ "${staging_tsv[*]}" =~ \* ]]; then
			# no staging files => safe to purge
			${scriptdir}/belfry purgeviollier
		else
			echo 'possible unsubmitted failed import?' > ${statusdir}/submit_fail
			echo -e '\e[31;1mLeft-over staging files\e[0m' > /dev/stderr
			printf ' - %s\n' "${staging_tsv[@]##*/}" > /dev/stderr
		fi

	fi
else
	echo 'There is already run going on'
fi

#
# Phase 5: run viloca on new samples if no viloca instance is running
#
if run_viloca; then

	echo "========================"
	echo "Check current VILOCA run"
	echo "========================"


	if [[ ( -e ${viloca_statusdir}/viloca_started ) && ( ( ! -e ${viloca_statusdir}/viloca_ended ) || ( ${viloca_statusdir}/viloca_started -nt ${viloca_statusdir}/viloca_ended ) ) ]]; then
		stillrunning=0
		while read j id; do
			# skip missing
			if [[ -z "${id}" ]]; then
				echo "VILOCA - $j : (not started)"
				continue
			fi

			# skip already finished
			if [[ ( -e ${viloca_statusdir}/viloca_${j}_ended ) && ( ${viloca_statusdir}/viloca_${j}_ended -nt ${viloca_statusdir}/viloca_started ) ]]; then
				old="$(<${viloca_statusdir}/viloca_${j}_ended)"
				if [[ "${id}" == "${old}" ]]; then
					echo "VILOCA - $j : $id already finished"
				else
					echo "VILOCA - $j : mismatch $id vs $old"
				fi
				continue
			fi

			# cluster status
			stat=$(${remote_batman} job "${id}" || echo "(no answer)")
			if [[ ( -n "${stat}" ) && ( ! "${stat}" =~ (EXIT|DONE) ) ]]; then
				# running
				echo -n "VILOCA - $j : $id : $stat"
				(( ++stillrunning ))
				if [[ "${stat}" == 'RUN' && ( ! "$j" =~ qa$ ) ]]; then
					echo -ne '\t'
					${remote_batman} completion "${id}" | tail -n 1
				else
					echo ''
				fi
				sleep 1
				continue
			fi

			# not running
			echo "VILOCA - $j : $id finishing"

			echo "${id}" > ${viloca_statusdir}/viloca_${j}_ended
		done < ${viloca_statusdir}/viloca_started

		if (( stillrunning == 0 )); then
			echo "No VILOCA running. Checking if the run was successful or if it ended prematurely due to the time limit"
			if grep -rq snake.err -e "JOB.*CANCELLED.*DUE TO TIME LIMIT"; then
				echo "Previous VILOCA run cancelled due to time limit. Restarting it"
				${remote_batman} unlock_viloca && \
				${remote_batman} viloca --recent --tag "${lastbatch_vpipe}" > ${viloca_statusdir}/viloca.${now}	&&	\
				if [[ -s ${viloca_statusdir}/viloca.${now} ]]; then
					ln -sf viloca.${now} ${viloca_statusdir}/viloca_started
					cat ${viloca_statusdir}/viloca_started
					printf "%s\t$(date '+%H%M%S')\n" "${runreason[@]}" | tee -a ${viloca_statusdir}/viloca_new.${now}
					if [[ -n "${mailto[*]}" ]]; then
						(
							echo '(Possibly new) samples not having VILOCA results yet found:'
							printf ' - %s\n' "${runreason[@]}"
							echo -e '\nStarting VILOCA on Euler:'
							cat ${viloca_statusdir}/viloca_started
						) | mail -s '[Automation-carillon] Starting VILOCA on Euler' "${mailto[@]}"
						# -r "${mailfrom}"
					fi
				fi
				continue
			fi
	    echo found
	else
	    echo not found
	fi
			${scriptdir}/belfry pullsamples_viloca --recent
			if [[ ( ! -e ${viloca_statusdir}/pullsamples_viloca_fail ) || ( ${viloca_statusdir}/pullsamples_viloca_success -nt ${viloca_statusdir}/pullsamples_viloca_fail ) ]]; then
				echo "$(basename $(realpath ${viloca_statusdir}/viloca_started))" > ${viloca_statusdir}/viloca_ended
			else
				echo "pulling VILOCA data failed"
			fi
		fi
	else
		echo 'No current VILOCA run.'
	fi

	#
	# Phase 6: restart VILOCA runs if new data
	#

	echo "===================="
	echo "Start new VILOCA run"
	echo "===================="
	mustrun_viloca=0
	if [[ ( ( ! -e ${viloca_statusdir}/viloca_ended ) && ( ! -e ${viloca_statusdir}/viloca_started ) ) || ( ${viloca_statusdir}/viloca_ended -nt ${viloca_statusdir}/viloca_started ) ]]; then
		#### TODO: HERE ADD THE LIMITATION TO RUN ONLY ON THE VERY LATEST BATCH AND RE-ADD BACK RUNREASON	
		ref=$(date --reference="${viloca_statusdir}/viloca_started" '+%Y%m%d')
		now=$(date '+%Y%m%d')
		limit=$(date --date='2 weeks ago' '+%Y%m%d')
		if [[ ! -f ${viloca_samples} ]]; then
			echo "Can't find ${viloca_samples}, creating it empty"
			echo ",sample,batch" > ${viloca_samples}
		fi
		if [[ ! -f ${viloca_staging} ]]; then
			echo "No staging file availabe, creating it"
			cat ${viloca_samples} > ${viloca_staging}

		else

		### TODO: HERE, just trust vpipe
		lastbatch_viloca = $(cat $(ls -Art ${viloca_statusdir}/viloca_new* | tail -n 1))
		echo "Last batch analysed by VILOCA is ${lastbatch_viloca}"
		vpipe_enddate = $(cat ${statusdir}/vpipe_ended)
		vpipe_enddate = ${vpipe_enddate#*.}
		lastbatch_vpipe = $(cat ${statusdir}/vpipe_new.${vpipe_enddate} | awk '{print $1}')
		echo "The most recent completed V-Pipe run is on batch ${lastbatch_vpipe}"
		if [[ lastbatch_viloca != lastbatch_vpipe ]]; then
			echo "There is a new most recent batch that VILOCA can run on!"
			t = ${basedir}/${sampleset}/samples.${lastbatch_vpipe}.tsv
			if [[ ! $t =~ samples.([[:digit:]]{8})_([[:alnum:]]{5,}(-[[:digit:]]+)?).tsv$ ]]; then
							echo "oops: Can't parse <${t}> ?!" > /dev/stderr
			fi
			cat $t | awk '{print $1,$2}' | tr " " "," | sed 's/^/,/' >> $viloca_staging
			cat $viloca_staging | sort | uniq > $viloca_staging
			++mustrun_viloca

		else
			echo "No new batch to run VILOCA on"
		fi
	
		# are we allowed to submit jobs ?
		if (( donotsubmit_viloca )); then
			echo -e '\e[35;1mWill NOT submit VILOCA jobs\e[0m...' > /dev/stderr
			if (( mustrun_viloca )); then
				echo 'VILOCA submit blocked' > ${viloca_statusdir}/viloca_submit_fail
				echo -e '...\e[33;1mbut there are new VILOCA jobs that should be started !!!\e[0m' > /dev/stderr
			else
				echo '...and there is nothing VILOCA-related to run anyway' > /dev/stderr
			fi
		# start jobs ?
		elif (( mustrun_viloca )); then
			echo 'New VILOCA job waiting. Checking if Viloca is already running...'
			if [[ ( -e ${viloca_statusdir}/viloca_started ) && ( ( ! -e ${viloca_statusdir}/viloca_ended ) || ( ${viloca_statusdir}/viloca_started -nt ${viloca_statusdir}/viloca_ended ) ) ]]; then
				echo "BUT there is already a VILOCA instance running! Retrying during the next loop"
			else
				echo 'starting VILOCA jobs'
				mv ${viloca_staging} ${viloca_samples}
				${remote_batman} viloca --recent --tag "${lastbatch_vpipe}" > ${viloca_statusdir}/viloca.${now}	&&	\
				if [[ -s ${viloca_statusdir}/viloca.${now} ]]; then
					ln -sf viloca.${now} ${viloca_statusdir}/viloca_started
					cat ${viloca_statusdir}/viloca_started
					printf "%s\t$(date '+%H%M%S')\n" "${runreason[@]}" | tee -a ${viloca_statusdir}/viloca_new.${now}
					if [[ -n "${mailto[*]}" ]]; then
						(
							echo '(Possibly new) samples not having VILOCA results yet found:'
							printf ' - %s\n' "${lastbatch_vpipe}"
							echo -e '\nStarting VILOCA on Euler:'
							cat ${viloca_statusdir}/viloca_started
						) | mail -s '[Automation-carillon] Starting VILOCA on Euler' "${mailto[@]}"
						# -r "${mailfrom}"
					fi
				fi
			fi
		else
			echo 'No new VILOCA jobs to start'
		fi
	else
		echo 'There is already A VILOCA run going on'
	fi
else
	echo "Skipping VILOCA as per configuration"
fi
#
# Closing words
#

${scriptdir}/belfry  df
${remote_batman} df
date -R
